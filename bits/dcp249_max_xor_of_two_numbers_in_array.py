"""
dcp#249
LC#421

This problem was asked by Salesforce.

Given an array of integers, find the maximum XOR of any two elements.

LeetCode: Can you do it in O(n) time?
"""

from timeit import default_timer as timer

"""
Solution #1: brute force
O(n^2) time
LC: TLE
"""
def max_xor(arr):
    n = len(arr)
    max_xor = 0

    for i in range(n):
        ai = arr[i]

        for j in range(i + 1, n):
            max_xor = max(ai ^ arr[j], max_xor)

    return max_xor

"""
Solution #2
Assume integers in given "arr" are 32-bit ints
O(n) time (to loop over prefixes), O(n) space (for prefixes)
"""
def max_xor2(arr):
    """ For building up the max xor bit-by-bit.
    This will be 0 until we get to first set bit (MSB) for any elt in arr. 
    """
    answer = 0 

    for i in range(31, -1, -1): # 31st bit to 0th bit
        # print("\ni = {}".format(i))
        # print("\nanswer = {}".format(answer))
        
        answer <<= 1
        # print("answer <<= 1 : {}".format(answer))

        """ Look at 31st to ith bit; O(n)
        Note: prefixes = {0} until we get to first set bit (MSB) for any elt in arr. 
        """
        prefixes = {x >> i for x in arr} # set
        # print("prefixes = {}".format(prefixes))
        
        """ answer ^ 1 sets the 0th bit to 1
        This is the new possible max xor fragment that we want to check for.
        """
        test_answer = answer ^ 1 # same as answer + 1
        # print("test_answer = answer ^ 1 = {}".format(test_answer))

        """ 
        Fact: x ^ y = z remains true for any permutation of x, y, z.
        Thus, p2 ^ p = test_answer <=> test_answer ^ p = p2
        
        The any() expression is checking if there are any two p's in prefixes
        that xor to test_answer.  If yes, then we can set the 0th bit of
        new answer to 1.
        O(1) to test inclusion in set, and O(n) to loop over prefixes.
        Overall O(n).
        """
        answer += any(test_answer ^ p in prefixes for p in prefixes)
        
        # s = [test_answer ^ p in prefixes for p in prefixes]
        # print("\n[test_answer ^ p in prefixes for p in prefixes] = {}".format(s))
        # print("\nfinal answer = {}".format(answer))
        # print("="*80)

    return answer

"""
Solution #2b
Same idea as solution #2, but using masks.
(and avoiding some Python idioms)
This is slower due to not using set comprehension for prefixes.
"""
def max_xor2b(arr):
    answer = 0
    mask = 0
    prefixes = set()
    n = len(arr)
    
    for i in range(31, -1, -1):
        bit_i = 1 << i
        mask |= bit_i

        #prefixes = {x & mask for x in arr} # this would be much faster
        for j in range(n):
            prefixes.add(arr[j] & mask)

        test_answer = answer | bit_i

        # if any(test_answer ^ p in prefixes for p in prefixes):
        #     answer = test_answer

        for prefix in prefixes:
            if test_answer ^ prefix in prefixes:
                answer = test_answer
                break

        prefixes.clear()

    return answer

###############################################################################

# Prints matrix generated by applying op pairwise to elements of arr.
# Some assumptions about the length of arr, and the sizes of its integer elts.
def print_op_matrix(arr, op, op_label='', pad=5):
    n = len(arr)
    op_label = op_label[:pad] # truncate label so it fits
    
    col_header = "{:^" + str(pad) + "}|"
    cell = "{:" + str(pad) + "}"

    # header row
    print()
    print(col_header.format(op_label), end="")
    for i in range(n):
        print(cell.format(arr[i]), end="")

    # boundary between header and rest of matrix
    print("\n" + "-"*pad + "|" + "-"*pad*n)

    # rest of matrix
    for i in range(n):
        # column header - first cell of each row in printed matrix
        print(col_header.format(arr[i]), end="")

        # actual data rows
        for j in range(n):
            x = op(arr[i], arr[j])
            print(cell.format(x), end="")

        print()


###############################################################################

if __name__ == "__main__":
    #arr = range(11)
    #arr = range(1000)
    #arr = [5]
    #arr = [2, 3]
    #arr = [1, 2, 4, 8, 16, 32, 64]

    #arr = [3, 10, 5, 25, 2, 8] # LC421, max xor is 5 ^ 25 = 28
    arr = [2, 3, 5, 8, 10, 25] # LC421, but sorted


    print("\narray = {}".format(arr))

    start = timer()
    m = max_xor(arr)
    t = timer() - start
    print("\ntime (sol#1)  = {}".format(t))

    start = timer()
    m2 = max_xor2(arr)
    t2 = timer() - start
    print("time (sol#2)  = {}".format(t2))

    start = timer()
    m2b = max_xor2b(arr)
    t2b = timer() - start
    print("time (sol#2b) = {}".format(t2b))

    print("\nmax XOR (sol#1)  = {}".format(m))
    print("\nmax XOR (sol#2)  = {}".format(m2))
    print("\nmax XOR (sol#2b) = {}".format(m2b))

    if len(arr) < 20:
        print_op_matrix(arr, lambda x, y: x^y, "^") 
